/**
 * Machine-readable Specification Schema
 *
 * Defines a structured format for specifications that can be:
 * 1. Generated by SpecAgent from chat conversations
 * 2. Consumed by SupervisorAgent for implementation planning
 * 3. Stored in database for traceability
 */

import { z } from 'zod';

/**
 * A single requirement item
 */
export const RequirementSchema = z.object({
  id: z.string().describe('Unique requirement ID (e.g., REQ-001)'),
  type: z.enum(['functional', 'non-functional', 'constraint']),
  priority: z.enum(['must', 'should', 'could', 'wont']).default('should'),
  description: z.string().describe('Clear description of the requirement'),
  acceptance_criteria: z.array(z.string()).optional()
    .describe('Testable criteria for this requirement'),
});

export type Requirement = z.infer<typeof RequirementSchema>;

/**
 * A component or module in the design
 */
export const ComponentSchema = z.object({
  name: z.string().describe('Component name'),
  description: z.string().describe('What this component does'),
  responsibilities: z.array(z.string()).describe('Key responsibilities'),
  dependencies: z.array(z.string()).optional()
    .describe('Other components this depends on'),
  files: z.array(z.string()).optional()
    .describe('Expected file paths for this component'),
});

export type Component = z.infer<typeof ComponentSchema>;

/**
 * API endpoint definition
 */
export const APIEndpointSchema = z.object({
  method: z.enum(['GET', 'POST', 'PUT', 'PATCH', 'DELETE']),
  path: z.string().describe('API path (e.g., /api/users/:id)'),
  description: z.string(),
  request_body: z.string().optional().describe('Request body schema description'),
  response: z.string().optional().describe('Response schema description'),
});

export type APIEndpoint = z.infer<typeof APIEndpointSchema>;

/**
 * Complete structured specification
 */
export const StructuredSpecSchema = z.object({
  version: z.literal('1.0'),
  metadata: z.object({
    title: z.string().describe('Specification title'),
    summary: z.string().describe('Brief summary (1-2 sentences)'),
    created_at: z.string(),
    updated_at: z.string(),
    spec_run_id: z.string().optional().describe('Run ID that created this spec'),
  }),
  overview: z.object({
    problem_statement: z.string().describe('What problem are we solving?'),
    proposed_solution: z.string().describe('High-level solution approach'),
    scope: z.string().optional().describe('What is in/out of scope'),
  }),
  requirements: z.array(RequirementSchema).describe('List of requirements'),
  design: z.object({
    architecture: z.string().optional().describe('Overall architecture description'),
    components: z.array(ComponentSchema).optional().describe('System components'),
    data_flow: z.string().optional().describe('How data flows through the system'),
  }).optional(),
  api: z.object({
    endpoints: z.array(APIEndpointSchema).optional(),
    notes: z.string().optional(),
  }).optional(),
  implementation_notes: z.array(z.string()).optional()
    .describe('Notes for the implementation phase'),
  test_plan: z.object({
    unit_tests: z.array(z.string()).optional(),
    integration_tests: z.array(z.string()).optional(),
    manual_tests: z.array(z.string()).optional(),
  }).optional(),
});

export type StructuredSpec = z.infer<typeof StructuredSpecSchema>;

/**
 * Create an empty structured spec template
 */
export function createEmptySpec(): StructuredSpec {
  const now = new Date().toISOString();
  return {
    version: '1.0',
    metadata: {
      title: '',
      summary: '',
      created_at: now,
      updated_at: now,
    },
    overview: {
      problem_statement: '',
      proposed_solution: '',
    },
    requirements: [],
  };
}

/**
 * Validate a spec object
 */
export function validateSpec(spec: unknown): { valid: boolean; errors?: string[] } {
  const result = StructuredSpecSchema.safeParse(spec);
  if (result.success) {
    return { valid: true };
  }
  return {
    valid: false,
    errors: result.error.errors.map(e => `${e.path.join('.')}: ${e.message}`),
  };
}

/**
 * Convert structured spec to markdown for human reading
 */
export function specToMarkdown(spec: StructuredSpec): string {
  const lines: string[] = [];

  lines.push(`# ${spec.metadata.title}`);
  lines.push('');
  lines.push(spec.metadata.summary);
  lines.push('');

  lines.push('## Overview');
  lines.push('');
  lines.push('### Problem Statement');
  lines.push(spec.overview.problem_statement);
  lines.push('');
  lines.push('### Proposed Solution');
  lines.push(spec.overview.proposed_solution);
  if (spec.overview.scope) {
    lines.push('');
    lines.push('### Scope');
    lines.push(spec.overview.scope);
  }
  lines.push('');

  if (spec.requirements.length > 0) {
    lines.push('## Requirements');
    lines.push('');
    for (const req of spec.requirements) {
      const priority = req.priority.toUpperCase();
      lines.push(`### ${req.id}: ${req.description}`);
      lines.push(`- **Type**: ${req.type}`);
      lines.push(`- **Priority**: ${priority}`);
      if (req.acceptance_criteria && req.acceptance_criteria.length > 0) {
        lines.push('- **Acceptance Criteria**:');
        for (const ac of req.acceptance_criteria) {
          lines.push(`  - ${ac}`);
        }
      }
      lines.push('');
    }
  }

  if (spec.design) {
    lines.push('## Design');
    lines.push('');
    if (spec.design.architecture) {
      lines.push('### Architecture');
      lines.push(spec.design.architecture);
      lines.push('');
    }
    if (spec.design.components && spec.design.components.length > 0) {
      lines.push('### Components');
      for (const comp of spec.design.components) {
        lines.push(`#### ${comp.name}`);
        lines.push(comp.description);
        lines.push('');
        lines.push('**Responsibilities**:');
        for (const resp of comp.responsibilities) {
          lines.push(`- ${resp}`);
        }
        if (comp.files && comp.files.length > 0) {
          lines.push('');
          lines.push('**Files**:');
          for (const file of comp.files) {
            lines.push(`- \`${file}\``);
          }
        }
        lines.push('');
      }
    }
    if (spec.design.data_flow) {
      lines.push('### Data Flow');
      lines.push(spec.design.data_flow);
      lines.push('');
    }
  }

  if (spec.api?.endpoints && spec.api.endpoints.length > 0) {
    lines.push('## API');
    lines.push('');
    for (const ep of spec.api.endpoints) {
      lines.push(`### ${ep.method} ${ep.path}`);
      lines.push(ep.description);
      if (ep.request_body) {
        lines.push(`- **Request**: ${ep.request_body}`);
      }
      if (ep.response) {
        lines.push(`- **Response**: ${ep.response}`);
      }
      lines.push('');
    }
  }

  if (spec.implementation_notes && spec.implementation_notes.length > 0) {
    lines.push('## Implementation Notes');
    lines.push('');
    for (const note of spec.implementation_notes) {
      lines.push(`- ${note}`);
    }
    lines.push('');
  }

  if (spec.test_plan) {
    lines.push('## Test Plan');
    lines.push('');
    if (spec.test_plan.unit_tests && spec.test_plan.unit_tests.length > 0) {
      lines.push('### Unit Tests');
      for (const t of spec.test_plan.unit_tests) {
        lines.push(`- ${t}`);
      }
      lines.push('');
    }
    if (spec.test_plan.integration_tests && spec.test_plan.integration_tests.length > 0) {
      lines.push('### Integration Tests');
      for (const t of spec.test_plan.integration_tests) {
        lines.push(`- ${t}`);
      }
      lines.push('');
    }
  }

  return lines.join('\n');
}
